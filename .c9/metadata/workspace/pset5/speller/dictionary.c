{"filter":false,"title":"dictionary.c","tooltip":"/pset5/speller/dictionary.c","undoManager":{"mark":11,"position":11,"stack":[[{"start":{"row":0,"column":0},"end":{"row":184,"column":1},"action":"insert","lines":["/**"," * dictionary.c"," *"," * Computer Science 50"," * Problem Set 5"," *"," * Implements a dictionary's functionality."," */","","#include \"dictionary.h\"","","// define struct for value-pointer pair, i.e., a node","typedef struct node","{","    char word[LENGTH + 1];","    struct node* next;","}","node;","","// create array of pointer-to-nodes of size HASHTABLE_SIZE","node* hashtable[HASHTABLE_SIZE];","","// global variable for tracking dictionary size","unsigned int word_count = 0;","","// global boolean for tracking load/unload dictionary operations","bool loaded = false;","","/**"," * Hash function via reddit user delipity:"," * https://www.reddit.com/r/cs50/comments/1x6vc8/pset6_trie_vs_hashtable/cf9nlkn"," */","int hash_it(char* needs_hashing)","{","    unsigned int hash = 0;","    for (int i=0, n=strlen(needs_hashing); i<n; i++)","        hash = (hash << 2) ^ needs_hashing[i];","    return hash % HASHTABLE_SIZE;","}","","/**"," * Returns true if word is in dictionary else false. Case-insensitive."," * Assume that check is only passed strings with alphabetical characters and/or"," * apostrophes."," */","bool check(const char* word)","{","    // create char array to store copy of word","    // word is a const char* and non-read actions cannot be performed on it","    int len = strlen(word);","    char word_copy[len + 1];","    ","    // convert word to lowercase and store it in word_copy","    for (int i = 0; i < len; i++)","    {","       word_copy[i] = tolower(word[i]);","    }","    ","    // add null terminator to end of char array","    word_copy[len] = '\\0';","    ","    // get hash value (a.k.a. bucket)","    int h = hash_it(word_copy);","    ","    // assign cursor node to the first node of the bucket","    node* cursor = hashtable[h];","    ","    // check until the end of the linked list","    while (cursor != NULL)","    {","        if (strcmp(cursor->word, word_copy) == 0)","        {","            // word is in dictionary","            return true;","        }","        else","        {","            // check next node","            cursor = cursor->next;","        }","    }","    return false;","}","","/**"," * Loads dictionary into memory. Stores words in hash table. Returns true if"," * successful else false."," */","bool load(const char* dictionary)","{","    // make all hash table elements NULL","    for (int i = 0; i < HASHTABLE_SIZE; i++)","    {","        hashtable[i] = NULL;","    }","    ","    // open dictionary","    FILE* fp = fopen(dictionary, \"r\");","    if (fp == NULL)","    {","        printf(\"Could not open dictionary.\\n\");","        return false;","    }","","    while (true)","    {","        // malloc a node for each new word","        node* new_node = malloc(sizeof(node));","        if (new_node == NULL)","        {","            printf(\"Could not malloc a new node.\\n\");","            return false;","        }","        ","        // read a word from the dictionary and store it in new_node->word","        fscanf(fp, \"%s\", new_node->word);","        new_node->next = NULL;","        ","        if (feof(fp))","        {","            // hit end of file","            free(new_node);","            break;","        }","","        word_count++;","        ","        // hashtable[h] is a pointer to a key-value pair","        int h = hash_it(new_node->word);","        node* head = hashtable[h];","        ","        // if bucket is empty, insert the first node","        if (head == NULL)","        {","            hashtable[h] = new_node;","        }","        // if bucket is not empty, attach node to front of list","        // design choice: unsorted linked list to minimize load time rather","        // than sorted linked list to minimize check time","        else","        {","            new_node->next = hashtable[h];","            hashtable[h] = new_node;","        }","    }","    // close dictionary","    fclose(fp);","    loaded = true;","    return true;","}","","/**"," * Returns number of words in dictionary if loaded else 0 if not yet loaded."," */","unsigned int size(void)","{","    if (loaded)","    {","        return word_count;","    }","    else","    {","        return 0;","    }","}","","/**"," * Unloads dictionary from memory.  Returns true if successful else false."," */","bool unload(void)","{","    for (int i = 0; i < HASHTABLE_SIZE; i++)","    {","        node* cursor = hashtable[i];","        while (cursor != NULL)","        {","            // maintain connection to linked list using temp","            node* temp = cursor;","            cursor = cursor->next;","            free(temp);","        }","    }","    loaded = false;","    return true;","}"],"id":1}],[{"start":{"row":51,"column":0},"end":{"row":51,"column":4},"action":"remove","lines":["    "],"id":2},{"start":{"row":57,"column":0},"end":{"row":57,"column":4},"action":"remove","lines":["    "]},{"start":{"row":60,"column":0},"end":{"row":60,"column":4},"action":"remove","lines":["    "]},{"start":{"row":63,"column":0},"end":{"row":63,"column":4},"action":"remove","lines":["    "]},{"start":{"row":66,"column":0},"end":{"row":66,"column":4},"action":"remove","lines":["    "]},{"start":{"row":95,"column":0},"end":{"row":95,"column":4},"action":"remove","lines":["    "]},{"start":{"row":113,"column":0},"end":{"row":113,"column":8},"action":"remove","lines":["        "]},{"start":{"row":117,"column":0},"end":{"row":117,"column":8},"action":"remove","lines":["        "]},{"start":{"row":126,"column":0},"end":{"row":126,"column":8},"action":"remove","lines":["        "]},{"start":{"row":130,"column":0},"end":{"row":130,"column":8},"action":"remove","lines":["        "]}],[{"start":{"row":0,"column":0},"end":{"row":184,"column":1},"action":"remove","lines":["/**"," * dictionary.c"," *"," * Computer Science 50"," * Problem Set 5"," *"," * Implements a dictionary's functionality."," */","","#include \"dictionary.h\"","","// define struct for value-pointer pair, i.e., a node","typedef struct node","{","    char word[LENGTH + 1];","    struct node* next;","}","node;","","// create array of pointer-to-nodes of size HASHTABLE_SIZE","node* hashtable[HASHTABLE_SIZE];","","// global variable for tracking dictionary size","unsigned int word_count = 0;","","// global boolean for tracking load/unload dictionary operations","bool loaded = false;","","/**"," * Hash function via reddit user delipity:"," * https://www.reddit.com/r/cs50/comments/1x6vc8/pset6_trie_vs_hashtable/cf9nlkn"," */","int hash_it(char* needs_hashing)","{","    unsigned int hash = 0;","    for (int i=0, n=strlen(needs_hashing); i<n; i++)","        hash = (hash << 2) ^ needs_hashing[i];","    return hash % HASHTABLE_SIZE;","}","","/**"," * Returns true if word is in dictionary else false. Case-insensitive."," * Assume that check is only passed strings with alphabetical characters and/or"," * apostrophes."," */","bool check(const char* word)","{","    // create char array to store copy of word","    // word is a const char* and non-read actions cannot be performed on it","    int len = strlen(word);","    char word_copy[len + 1];","","    // convert word to lowercase and store it in word_copy","    for (int i = 0; i < len; i++)","    {","       word_copy[i] = tolower(word[i]);","    }","","    // add null terminator to end of char array","    word_copy[len] = '\\0';","","    // get hash value (a.k.a. bucket)","    int h = hash_it(word_copy);","","    // assign cursor node to the first node of the bucket","    node* cursor = hashtable[h];","","    // check until the end of the linked list","    while (cursor != NULL)","    {","        if (strcmp(cursor->word, word_copy) == 0)","        {","            // word is in dictionary","            return true;","        }","        else","        {","            // check next node","            cursor = cursor->next;","        }","    }","    return false;","}","","/**"," * Loads dictionary into memory. Stores words in hash table. Returns true if"," * successful else false."," */","bool load(const char* dictionary)","{","    // make all hash table elements NULL","    for (int i = 0; i < HASHTABLE_SIZE; i++)","    {","        hashtable[i] = NULL;","    }","","    // open dictionary","    FILE* fp = fopen(dictionary, \"r\");","    if (fp == NULL)","    {","        printf(\"Could not open dictionary.\\n\");","        return false;","    }","","    while (true)","    {","        // malloc a node for each new word","        node* new_node = malloc(sizeof(node));","        if (new_node == NULL)","        {","            printf(\"Could not malloc a new node.\\n\");","            return false;","        }","","        // read a word from the dictionary and store it in new_node->word","        fscanf(fp, \"%s\", new_node->word);","        new_node->next = NULL;","","        if (feof(fp))","        {","            // hit end of file","            free(new_node);","            break;","        }","","        word_count++;","","        // hashtable[h] is a pointer to a key-value pair","        int h = hash_it(new_node->word);","        node* head = hashtable[h];","","        // if bucket is empty, insert the first node","        if (head == NULL)","        {","            hashtable[h] = new_node;","        }","        // if bucket is not empty, attach node to front of list","        // design choice: unsorted linked list to minimize load time rather","        // than sorted linked list to minimize check time","        else","        {","            new_node->next = hashtable[h];","            hashtable[h] = new_node;","        }","    }","    // close dictionary","    fclose(fp);","    loaded = true;","    return true;","}","","/**"," * Returns number of words in dictionary if loaded else 0 if not yet loaded."," */","unsigned int size(void)","{","    if (loaded)","    {","        return word_count;","    }","    else","    {","        return 0;","    }","}","","/**"," * Unloads dictionary from memory.  Returns true if successful else false."," */","bool unload(void)","{","    for (int i = 0; i < HASHTABLE_SIZE; i++)","    {","        node* cursor = hashtable[i];","        while (cursor != NULL)","        {","            // maintain connection to linked list using temp","            node* temp = cursor;","            cursor = cursor->next;","            free(temp);","        }","    }","    loaded = false;","    return true;","}"],"id":3},{"start":{"row":0,"column":0},"end":{"row":175,"column":1},"action":"insert","lines":["/**"," * dictionary.c"," *"," * Computer Science 50"," * Problem Set 5"," *"," * Implements a dictionary's functionality."," */","","#include <stdbool.h>","#include <stdlib.h>","#include <stdio.h>","#include <ctype.h>","","#include \"dictionary.h\"","","typedef struct node","{","    bool is_word;","    struct node* children[27];","}","node;","","node* root;","","/**"," * Recursive function to free node from bottom to top"," */","void freeing(node* children)","{","    for (int i = 0; i < 27; i++)","    {","        if (children->children[i] != NULL)","        {","            freeing(children->children[i]);","        }","    }","    ","    free(children);","}","","// create global variable to count size","int dictionarySize = 0;","","/**"," * Returns true if word is in dictionary else false."," */","bool check(const char* word)","{","    int index;","    // create a pointer to first node","    node* trav = root;","    ","    for (int i = 0; word[i] != '\\0'; i++)","    {","        // if letter is apostrophe","        if (word[i] == '\\'')","        {","            index = 26;","        }","        else","        // convert each letter to an index, e.g a is 0","        {","            index = tolower(word[i]) - 'a';","        }","        ","        // traverse to next letter","        trav = trav->children[index];","        ","        // if NULL, word is misspelled","        if (trav == NULL)","        {","            return false;","        }","    }","    ","    // once at end of word, check if is_word is true","    if (trav->is_word == true)","    {","        return true;","    }","    else","    {","        return false;","    }","}","","/**"," * Loads dictionary into memory.  Returns true if successful else false."," */","bool load(const char* dictionary)","{","    // opening the dictionary file","    FILE* fp = fopen(dictionary, \"r\");","    int index;","    char word[LENGTH+1];","    ","    // if cannot open file, return false","    if (fp == NULL)","    {","        return false;","    }","    ","    // Creating Tries and initialize default value & pointer","    root = malloc(sizeof(node));","    root->is_word = false;","    for (int j = 0; j < 27; j++)","    {","        root->children[j] = NULL;","    }","    ","    // Building of tries from dictionary with loop","    // Scan each word line by line from dictionaries","    while(fscanf(fp, \"%s\\n\", word) != EOF)","    {","        // Create a traversal pointer from start of Tries","        node* trav = root;","        ","        // For every dictionary word, iterate through trie","        for (int i = 0; word[i] != '\\0'; i++)","        {","            // if letter is apostrophe","            if (word[i] == '\\'')","            {","                index = 26;","            }","            else","            // convert each letter to an index, e.g a is 0","            {","                index = tolower(word[i]) - 'a';","            }","            ","            if (trav->children[index] == NULL)","            {","                // if NULL, malloc new node","                node* new_node = malloc(sizeof(node));","                new_node->is_word = false;","                for (int k = 0; k < 27; k++)","                {","                    new_node->children[k] = NULL;","                }","                // and set children[index] to point at it","                trav->children[index] = new_node;","            }","            // move traversal pointer to it","            trav = trav->children[index];","        }","        // At end of word, set is_word true;","        trav->is_word = true;","        dictionarySize++;","    }","    ","    // close file","    fclose(fp);","    ","    // return true if successful","    return true;","}","","/**"," * Returns number of words in dictionary if loaded else 0 if not yet loaded."," */","unsigned int size(void)","{","    return dictionarySize;","}","","/**"," * Unloads dictionary from memory.  Returns true if successful else false."," */","bool unload(void)","{","    node* trav = root;","    freeing(trav);","    return true;","}"]}],[{"start":{"row":37,"column":0},"end":{"row":37,"column":4},"action":"remove","lines":["    "],"id":4},{"start":{"row":52,"column":0},"end":{"row":52,"column":4},"action":"remove","lines":["    "]},{"start":{"row":65,"column":0},"end":{"row":65,"column":8},"action":"remove","lines":["        "]},{"start":{"row":68,"column":0},"end":{"row":68,"column":8},"action":"remove","lines":["        "]},{"start":{"row":75,"column":0},"end":{"row":75,"column":4},"action":"remove","lines":["    "]},{"start":{"row":96,"column":0},"end":{"row":96,"column":4},"action":"remove","lines":["    "]},{"start":{"row":102,"column":0},"end":{"row":102,"column":4},"action":"remove","lines":["    "]},{"start":{"row":110,"column":0},"end":{"row":110,"column":4},"action":"remove","lines":["    "]},{"start":{"row":117,"column":0},"end":{"row":117,"column":8},"action":"remove","lines":["        "]},{"start":{"row":131,"column":0},"end":{"row":131,"column":12},"action":"remove","lines":["            "]},{"start":{"row":151,"column":0},"end":{"row":151,"column":4},"action":"remove","lines":["    "]},{"start":{"row":154,"column":0},"end":{"row":154,"column":4},"action":"remove","lines":["    "]}],[{"start":{"row":93,"column":11},"end":{"row":93,"column":12},"action":"remove","lines":["p"],"id":5}],[{"start":{"row":93,"column":11},"end":{"row":93,"column":12},"action":"insert","lines":["i"],"id":6}],[{"start":{"row":93,"column":12},"end":{"row":93,"column":13},"action":"insert","lines":["l"],"id":7}],[{"start":{"row":93,"column":13},"end":{"row":93,"column":14},"action":"insert","lines":["e"],"id":8}],[{"start":{"row":93,"column":13},"end":{"row":93,"column":14},"action":"remove","lines":["e"],"id":9}],[{"start":{"row":93,"column":12},"end":{"row":93,"column":13},"action":"remove","lines":["l"],"id":10}],[{"start":{"row":93,"column":11},"end":{"row":93,"column":12},"action":"remove","lines":["i"],"id":11}],[{"start":{"row":93,"column":11},"end":{"row":93,"column":12},"action":"insert","lines":["p"],"id":12}]]},"ace":{"folds":[],"scrolltop":116,"scrollleft":0,"selection":{"start":{"row":24,"column":0},"end":{"row":24,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1529591947576,"hash":"e3d6f2986678d8c33459b2ea8fb57d10c1ad8af8"}